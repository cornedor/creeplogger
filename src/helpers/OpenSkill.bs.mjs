// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Openskill from "openskill";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.mjs";
import * as RescriptCore from "@rescript/core/src/RescriptCore.bs.mjs";

function createRating(muOpt, sigmaOpt, param) {
  var mu = muOpt !== undefined ? muOpt : 25.0;
  var sigma = sigmaOpt !== undefined ? sigmaOpt : 8.333;
  return Openskill.rating({
              mu: mu,
              sigma: sigma
            });
}

function defaultRating() {
  return Openskill.rating();
}

function getOrdinal(rating) {
  return Openskill.ordinal(rating);
}

function rateGame(winningTeam, losingTeam) {
  var teams = [
    winningTeam,
    losingTeam
  ];
  var results = Openskill.rate(teams, {
        balance: true
      });
  if (results.length !== 2) {
    return RescriptCore.panic("Unexpected result from rate function");
  }
  var winnerUpdates = results[0];
  var loserUpdates = results[1];
  return [
          winnerUpdates,
          loserUpdates
        ];
}

function getWinProbability(teamA, teamB) {
  var probabilities = Openskill.predictWin([
        teamA,
        teamB
      ]);
  return probabilities[0];
}

function playerToRating(player) {
  var sigmaOpt = player.sigma;
  var muOpt = player.mu;
  return Openskill.rating({
              mu: muOpt,
              sigma: sigmaOpt
            });
}

function getTeamAverageRating(team) {
  var totalMu = Core__Array.reduce(team, 0.0, (function (acc, rating) {
          return acc + rating.mu;
        }));
  var totalSigma = Core__Array.reduce(team, 0.0, (function (acc, rating) {
          return acc + rating.sigma;
        }));
  var teamSize = team.length;
  if (teamSize <= 0.0) {
    return Openskill.rating();
  }
  var sigmaOpt = totalSigma / teamSize;
  var muOpt = totalMu / teamSize;
  return Openskill.rating({
              mu: muOpt,
              sigma: sigmaOpt
            });
}

function calculateExpectationAwareScoreMultiplier(winnerScore, loserScore, winProbability) {
  var scoreDiff = winnerScore - loserScore | 0;
  var loserScoreRatio = loserScore / 7.0;
  var baseMultiplier = 0.7 + (scoreDiff - 1.0) * 0.1;
  var expectationAdjustment = winProbability > 0.8 ? (
      loserScoreRatio > 0.7 ? 0.5 : (
          loserScoreRatio > 0.4 ? 0.8 : 1.0
        )
    ) : (
      winProbability > 0.6 ? (
          loserScoreRatio > 0.7 ? 0.7 : (
              loserScoreRatio < 0.3 ? 1.2 : 1.0
            )
        ) : (
          winProbability < 0.3 ? (
              loserScoreRatio < 0.3 ? 1.5 : (
                  loserScoreRatio > 0.7 ? 1.1 : 1.3
                )
            ) : (
              scoreDiff === 1 ? 0.9 : (
                  scoreDiff >= 6 ? 1.3 : 1.0
                )
            )
        )
    );
  return baseMultiplier * expectationAdjustment;
}

function calculateTeamVariance(team) {
  var teamSize = team.length;
  if (teamSize <= 1.0) {
    return 0.0;
  }
  var ordinals = team.map(function (rating) {
        return Openskill.ordinal(rating);
      });
  var mean = Core__Array.reduce(ordinals, 0.0, (function (acc, ord) {
          return acc + ord;
        })) / teamSize;
  return Math.sqrt(Core__Array.reduce(ordinals, 0.0, (function (acc, ord) {
                    var diff = ord - mean;
                    return acc + diff * diff;
                  })) / teamSize);
}

function calculateTeamStrengthDifference(teamA, teamB) {
  var avgA = Core__Array.reduce(teamA, 0.0, (function (acc, rating) {
          return acc + Openskill.ordinal(rating);
        })) / teamA.length;
  var avgB = Core__Array.reduce(teamB, 0.0, (function (acc, rating) {
          return acc + Openskill.ordinal(rating);
        })) / teamB.length;
  return Math.abs(avgA - avgB);
}

function calculateSmartMultiplier(winnerTeam, loserTeam) {
  var winProbability = getWinProbability(winnerTeam, loserTeam);
  var winnerVariance = calculateTeamVariance(winnerTeam);
  var loserVariance = calculateTeamVariance(loserTeam);
  var maxInternalVariance = Math.max(winnerVariance, loserVariance);
  var teamStrengthDiff = calculateTeamStrengthDifference(winnerTeam, loserTeam);
  var internalImbalanceFactor = Math.tanh(maxInternalVariance / 10.0);
  var teamImbalanceFactor = Math.tanh(teamStrengthDiff / 15.0);
  var totalImbalance = internalImbalanceFactor + teamImbalanceFactor + 0.1;
  var internalWeight = internalImbalanceFactor / totalImbalance;
  var teamWeight = 1.0 - internalWeight;
  var isWinnerFavored = winProbability > 0.5;
  var multiplier;
  if (internalWeight > 0.6) {
    var baseDampening = 1.0 - 0.7 * internalImbalanceFactor;
    multiplier = isWinnerFavored && winProbability > 0.7 ? baseDampening * 0.8 : baseDampening;
  } else if (teamWeight > 0.6) {
    multiplier = winProbability < 0.3 ? 1.0 + 0.5 * teamImbalanceFactor : (
        winProbability > 0.7 ? 1.0 - 0.2 * teamImbalanceFactor : 1.0
      );
  } else {
    var balanceFactor = 1.0 - Math.abs(0.5 - winProbability) * 2.0;
    multiplier = 1.0 - 0.3 * internalImbalanceFactor * balanceFactor;
  }
  return Math.max(0.3, Math.min(1.5, multiplier));
}

export {
  createRating ,
  defaultRating ,
  getOrdinal ,
  rateGame ,
  getWinProbability ,
  playerToRating ,
  getTeamAverageRating ,
  calculateExpectationAwareScoreMultiplier ,
  calculateTeamVariance ,
  calculateTeamStrengthDifference ,
  calculateSmartMultiplier ,
}
/* openskill Not a pure module */
