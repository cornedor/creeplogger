// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Rules from "./Rules.bs.mjs";
import * as React from "react";
import * as Schema from "./Schema.bs.mjs";
import * as Database from "./Database.bs.mjs";
import * as RescriptCore from "@rescript/core/src/RescriptCore.bs.mjs";
import * as FirebaseSchema from "./FirebaseSchema.bs.mjs";
import * as Database$1 from "firebase/database";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

let playerSchema = Schema.object(s => ({
  name: s.f("name", Schema.string),
  wins: s.fieldOr("wins", Schema.int, 0),
  losses: s.fieldOr("losses", Schema.int, 0),
  absoluteWins: s.fieldOr("absoluteWins", Schema.int, 0),
  absoluteLosses: s.fieldOr("absoluteLosses", Schema.int, 0),
  games: s.fieldOr("games", Schema.int, 0),
  teamGoals: s.fieldOr("teamGoals", Schema.int, 0),
  teamGoalsAgainst: s.fieldOr("teamGoalsAgainst", Schema.int, 0),
  blueGames: s.fieldOr("blueGames", Schema.int, 0),
  redGames: s.fieldOr("redGames", Schema.int, 0),
  blueWins: s.fieldOr("blueWins", Schema.int, 0),
  redWins: s.fieldOr("redWins", Schema.int, 0),
  elo: s.fieldOr("elo", Schema.float, 1000.0),
  lastEloChange: s.fieldOr("change", Schema.float, 0.0),
  key: s.f("key", Schema.string),
  mattermostHandle: s.f("mh", FirebaseSchema.nullableTransform(Schema.option(Schema.string))),
  lastGames: s.fieldOr("lastGames", Schema.array(Schema.int), []),
  hidden: s.f("hidden", FirebaseSchema.nullableTransform(Schema.option(Schema.bool))),
  mu: s.fieldOr("mu", Schema.float, 25.0),
  sigma: s.fieldOr("sigma", Schema.float, 8.333),
  ordinal: s.fieldOr("ordinal", Schema.float, 0.0),
  lastOpenSkillChange: s.fieldOr("osChange", Schema.float, 0.0),
  dartsElo: s.fieldOr("dartsElo", Schema.float, 1000.0),
  dartsLastEloChange: s.fieldOr("dartsChange", Schema.float, 0.0),
  dartsGames: s.fieldOr("dartsGames", Schema.int, 0),
  dartsWins: s.fieldOr("dartsWins", Schema.int, 0),
  dartsLosses: s.fieldOr("dartsLosses", Schema.int, 0),
  dartsLastGames: s.fieldOr("dartsLastGames", Schema.array(Schema.int), [])
}));

let playersSchema = Schema.dict(playerSchema);

async function addPlayer(name) {
  let playersRef = Database$1.ref(Database.database, "players");
  let data;
  try {
    data = Schema.convertToJsonOrThrow({
      name: name,
      wins: 0,
      losses: 0,
      absoluteWins: 0,
      absoluteLosses: 0,
      games: 0,
      teamGoals: 0,
      teamGoalsAgainst: 0,
      blueGames: 0,
      redGames: 0,
      blueWins: 0,
      redWins: 0,
      elo: 1000.0,
      lastEloChange: 0.0,
      key: "",
      mattermostHandle: undefined,
      lastGames: [],
      hidden: undefined,
      mu: 25.0,
      sigma: 8.333,
      ordinal: 0.0,
      lastOpenSkillChange: 0.0,
      dartsElo: 1000.0,
      dartsLastEloChange: 0.0,
      dartsGames: 0,
      dartsWins: 0,
      dartsLosses: 0,
      dartsLastGames: []
    }, playerSchema);
  } catch (exn) {
    data = RescriptCore.panic("Could not serialize player");
  }
  let ref = await Database$1.push(playersRef, data);
  let key = ref.key;
  if (!(key == null)) {
    await Database$1.set(Database$1.ref(Database.database, "players/" + key + "/key"), key);
  }
  return ref;
}

function useAllPlayers(orderByOpt, ascOpt) {
  let orderBy = orderByOpt !== undefined ? orderByOpt : "rating";
  let asc = ascOpt !== undefined ? ascOpt : false;
  let match = React.useState(() => []);
  let setPlayers = match[1];
  let players = match[0];
  let playersRef = Database$1.query(Database$1.ref(Database.database, "players"), Database$1.orderByChild("games"));
  React.useEffect(() => Database$1.onValue(playersRef, snapshot => {
    let newPlayers = [];
    snapshot.forEach(snap => {
      let val = snap.val();
      if (val == null) {
        return;
      }
      try {
        let player = Schema.parseOrThrow(val, playerSchema);
        newPlayers.push(player);
        return;
      } catch (exn) {
        return;
      }
    });
    setPlayers(param => newPlayers);
  }, undefined), [setPlayers]);
  return React.useMemo(() => players.toSorted((a, b) => {
    let match = asc ? [
        a,
        b
      ] : [
        b,
        a
      ];
    let b$1 = match[1];
    let a$1 = match[0];
    if (orderBy === "elo") {
      return a$1.elo - b$1.elo;
    } else if (orderBy === "games") {
      return a$1.games - b$1.games | 0;
    } else if (orderBy === "rating") {
      return a$1.ordinal - b$1.ordinal;
    } else {
      return a$1.dartsElo - b$1.dartsElo;
    }
  }), [
    players,
    asc,
    orderBy
  ]);
}

async function fetchAllPlayers() {
  let playersRef = Database$1.ref(Database.database, "players");
  let data = await Database$1.get(playersRef);
  let empty = {};
  let data$1 = data.val();
  if (data$1 == null) {
    return empty;
  }
  try {
    return Schema.parseOrThrow(data$1, playersSchema);
  } catch (exn) {
    return empty;
  }
}

async function fetchPlayerByKey(key) {
  let playerRef = Database$1.ref(Database.database, "players/" + key);
  let data = await Database$1.get(playerRef);
  let player = data.val();
  if (player == null) {
    return;
  }
  try {
    return Schema.parseOrThrow(player, playerSchema);
  } catch (raw_error) {
    let error = Primitive_exceptions.internalToException(raw_error);
    console.error(error);
    return;
  }
}

function playerByKey(players, key) {
  return players.find(c => c.key === key);
}

function writePlayer(player) {
  let playerRef = Database$1.ref(Database.database, "players/" + player.key);
  return Database$1.set(playerRef, Schema.convertToJsonOrThrow(player, playerSchema));
}

function getLastGames(lastGames, win) {
  let newGames = lastGames.concat([win ? 1 : 0]);
  return newGames.slice(-5);
}

function updateGameStats(key, myTeamPoints, opponentTeamPoints, team, elo) {
  let isAbsolute = Rules.isAbsolute(myTeamPoints, opponentTeamPoints);
  let isWin = myTeamPoints > opponentTeamPoints;
  let isAbsoluteWin = isAbsolute && isWin;
  let isLoss = myTeamPoints < opponentTeamPoints;
  let isAbsoluteLoss = isAbsolute && isLoss;
  let isRedWin = team === "Red" && isWin;
  let isBlueWin = team === "Blue" && isWin;
  let playerRef = Database$1.ref(Database.database, "players/" + key);
  return Database$1.runTransaction(playerRef, data => {
    try {
      let player = Schema.parseOrThrow(data, playerSchema);
      let newrecord = {...player};
      return Schema.convertToJsonOrThrow((newrecord.lastGames = getLastGames(player.lastGames, isWin), newrecord.lastEloChange = elo - player.elo, newrecord.elo = elo, newrecord.redWins = isRedWin ? player.redWins + 1 | 0 : player.redWins, newrecord.blueWins = isBlueWin ? player.blueWins + 1 | 0 : player.blueWins, newrecord.redGames = team === "Red" ? player.redGames + 1 | 0 : player.redGames, newrecord.blueGames = team === "Blue" ? player.blueGames + 1 | 0 : player.blueGames, newrecord.teamGoalsAgainst = player.teamGoalsAgainst + opponentTeamPoints | 0, newrecord.teamGoals = player.teamGoals + myTeamPoints | 0, newrecord.games = player.games + 1 | 0, newrecord.absoluteLosses = isAbsoluteLoss ? player.absoluteLosses + 1 | 0 : player.absoluteLosses, newrecord.absoluteWins = isAbsoluteWin ? player.absoluteWins + 1 | 0 : player.absoluteWins, newrecord.losses = isLoss ? player.losses + 1 | 0 : player.losses, newrecord.wins = isWin ? player.wins + 1 | 0 : player.wins, newrecord), playerSchema);
    } catch (exn) {
      return data;
    }
  });
}

function updateOpenSkillGameStats(key, _myTeamPoints, _opponentTeamPoints, _team, mu, sigma, ordinal) {
  let playerRef = Database$1.ref(Database.database, "players/" + key);
  return Database$1.runTransaction(playerRef, data => {
    try {
      let player = Schema.parseOrThrow(data, playerSchema);
      let newrecord = {...player};
      return Schema.convertToJsonOrThrow((newrecord.lastOpenSkillChange = ordinal - player.ordinal, newrecord.ordinal = ordinal, newrecord.sigma = sigma, newrecord.mu = mu, newrecord), playerSchema);
    } catch (exn) {
      return data;
    }
  });
}

function updateDartsGameStats(key, myTeamPoints, elo) {
  let isWin = myTeamPoints === 1;
  let isLoss = myTeamPoints === 0;
  let playerRef = Database$1.ref(Database.database, "players/" + key);
  return Database$1.runTransaction(playerRef, data => {
    try {
      let player = Schema.parseOrThrow(data, playerSchema);
      let newrecord = {...player};
      return Schema.convertToJsonOrThrow((newrecord.dartsLastGames = getLastGames(player.dartsLastGames, isWin), newrecord.dartsLosses = isLoss ? player.dartsLosses + 1 | 0 : player.dartsLosses, newrecord.dartsWins = isWin ? player.dartsWins + 1 | 0 : player.dartsWins, newrecord.dartsGames = player.dartsGames + 1 | 0, newrecord.dartsLastEloChange = elo - player.dartsElo, newrecord.dartsElo = elo, newrecord), playerSchema);
    } catch (exn) {
      return data;
    }
  });
}

function removePlayer(playerKey) {
  return Database$1.remove(Database$1.ref(Database.database, "players/" + playerKey));
}

let bucket = "players";

export {
  bucket,
  addPlayer,
  useAllPlayers,
  fetchAllPlayers,
  fetchPlayerByKey,
  playerByKey,
  updateGameStats,
  updateOpenSkillGameStats,
  updateDartsGameStats,
  writePlayer,
  getLastGames,
  playersSchema,
  removePlayer,
}
/* playerSchema Not a pure module */
