// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Elo from "./Elo.bs.mjs";
import * as Games from "./Games.bs.mjs";
import * as Rules from "./Rules.bs.mjs";
import * as React from "react";
import * as Schema from "./Schema.bs.mjs";
import * as Players from "./Players.bs.mjs";
import * as Database from "./Database.bs.mjs";
import * as DartsGames from "./DartsGames.bs.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.mjs";
import * as RescriptCore from "@rescript/core/src/RescriptCore.bs.mjs";
import * as OpenSkillRating from "./OpenSkillRating.bs.mjs";
import * as Database$1 from "firebase/database";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

let _ignoreOpenSkill = OpenSkillRating.roundScore(0.0);

let statsSchema = Schema.object(s => ({
  totalGames: s.fieldOr("games", Schema.int, 0),
  totalRedWins: s.fieldOr("redWins", Schema.int, 0),
  totalBlueWins: s.fieldOr("blueWins", Schema.int, 0),
  totalAbsoluteWins: s.fieldOr("absoluteWins", Schema.int, 0),
  totalDartsGames: s.fieldOr("dartsGames", Schema.int, 0)
}));

let empty = {
  totalGames: 0,
  totalRedWins: 0,
  totalBlueWins: 0,
  totalAbsoluteWins: 0,
  totalDartsGames: 0
};

let bucket = "stats";

async function fetchStats() {
  let stats = await Database$1.get(Database$1.ref(Database.database, bucket));
  let stats$1 = stats.val();
  if (stats$1 == null) {
    return;
  }
  try {
    return Schema.parseOrThrow(stats$1, statsSchema);
  } catch (raw_error) {
    let error = Primitive_exceptions.internalToException(raw_error);
    console.error(error);
    return;
  }
}

function useStats() {
  let match = React.useState(() => empty);
  let setStats = match[1];
  let statsRef = Database$1.ref(Database.database, bucket);
  React.useEffect(() => Database$1.onValue(statsRef, snapshot => {
    let stats = snapshot.val();
    if (stats == null) {
      return;
    }
    try {
      return setStats(param => Schema.parseOrThrow(stats, statsSchema));
    } catch (raw_error) {
      let error = Primitive_exceptions.internalToException(raw_error);
      console.error(error);
      return;
    }
  }, undefined), []);
  return match[0];
}

async function updateStats(redScore, blueScore) {
  let blueWin = Rules.isBlueWin(redScore, blueScore);
  let redWin = Rules.isRedWin(redScore, blueScore);
  let isAbsolute = Rules.isAbsolute(redScore, blueScore);
  let statsRef = Database$1.ref(Database.database, bucket);
  return Database$1.runTransaction(statsRef, data => {
    try {
      let parsedData = Schema.parseOrThrow(data, statsSchema);
      return Schema.convertToJsonOrThrow({
        totalGames: parsedData.totalGames + 1 | 0,
        totalRedWins: parsedData.totalRedWins + (
          redWin ? 1 : 0
        ) | 0,
        totalBlueWins: parsedData.totalBlueWins + (
          blueWin ? 1 : 0
        ) | 0,
        totalAbsoluteWins: parsedData.totalAbsoluteWins + (
          isAbsolute ? 1 : 0
        ) | 0,
        totalDartsGames: parsedData.totalDartsGames
      }, statsSchema);
    } catch (exn) {
      return RescriptCore.panic("Failed parsing stats");
    }
  });
}

async function updateDartsStats() {
  let statsRef = Database$1.ref(Database.database, bucket);
  return Database$1.runTransaction(statsRef, data => {
    try {
      let parsedData = Schema.parseOrThrow(data, statsSchema);
      return Schema.convertToJsonOrThrow({
        totalGames: parsedData.totalGames,
        totalRedWins: parsedData.totalRedWins,
        totalBlueWins: parsedData.totalBlueWins,
        totalAbsoluteWins: parsedData.totalAbsoluteWins,
        totalDartsGames: parsedData.totalDartsGames + 1 | 0
      }, statsSchema);
    } catch (exn) {
      return RescriptCore.panic("Failed parsing stats");
    }
  });
}

async function writeStats(stats) {
  let statsRef = Database$1.ref(Database.database, bucket);
  let data;
  try {
    let data$1 = Schema.convertToJsonOrThrow(stats, statsSchema);
    console.log("Log", data$1);
    data = data$1;
  } catch (exn) {
    data = RescriptCore.panic("Could not serialize stats");
  }
  return await Database$1.set(statsRef, data);
}

async function recalculateStats() {
  let games = await Games.fetchAllGames();
  let dartsGames = await DartsGames.fetchAllGames();
  let players = await Players.fetchAllPlayers();
  let playerKeys = Object.keys(players);
  playerKeys.forEach(key => {
    let player = Core__Option.getExn(players[key], undefined);
    let newrecord = {...player};
    newrecord.dartsLastGames = [];
    newrecord.dartsLosses = 0;
    newrecord.dartsWins = 0;
    newrecord.dartsGames = 0;
    newrecord.dartsLastEloChange = 0.0;
    newrecord.dartsElo = 1000.0;
    newrecord.ordinal = 0.0;
    newrecord.sigma = 8.333;
    newrecord.mu = 25.0;
    newrecord.lastGames = [];
    newrecord.lastEloChange = 0.0;
    newrecord.elo = 1000.0;
    newrecord.redWins = 0;
    newrecord.blueWins = 0;
    newrecord.redGames = 0;
    newrecord.blueGames = 0;
    newrecord.teamGoalsAgainst = 0;
    newrecord.teamGoals = 0;
    newrecord.games = 0;
    newrecord.absoluteLosses = 0;
    newrecord.absoluteWins = 0;
    newrecord.losses = 0;
    newrecord.wins = 0;
    players[key] = newrecord;
  });
  let stats = Core__Array.reduce(games, empty, (stats, game) => {
    let blueWin = Rules.isBlueWin(game.redScore, game.blueScore);
    let redWin = Rules.isRedWin(game.redScore, game.blueScore);
    let isAbsolute = Rules.isAbsolute(game.redScore, game.blueScore);
    let redPlayers = game.redTeam.map(key => Core__Option.getExn(players[key], undefined));
    let bluePlayers = game.blueTeam.map(key => Core__Option.getExn(players[key], undefined));
    let match;
    if (blueWin) {
      match = OpenSkillRating.calculateScore(bluePlayers, redPlayers, "Foosball");
    } else {
      let match$1 = OpenSkillRating.calculateScore(redPlayers, bluePlayers, "Foosball");
      match = [
        match$1[1],
        match$1[0],
        match$1[2]
      ];
    }
    let redPlayers$1 = match[1];
    let bluePlayers$1 = match[0];
    let match$2;
    if (blueWin) {
      match$2 = Elo.calculateScore(bluePlayers$1, redPlayers$1, "Foosball");
    } else {
      let match$3 = Elo.calculateScore(redPlayers$1, bluePlayers$1, "Foosball");
      match$2 = [
        match$3[1],
        match$3[0],
        match$3[2]
      ];
    }
    match$2[0].forEach(player => {
      let lastGames = Players.getLastGames(player.lastGames, blueWin);
      let newrecord = {...player};
      newrecord.lastGames = lastGames;
      newrecord.blueWins = blueWin ? player.blueWins + 1 | 0 : player.blueWins;
      newrecord.blueGames = player.blueGames + 1 | 0;
      newrecord.teamGoalsAgainst = player.teamGoalsAgainst + game.redScore | 0;
      newrecord.teamGoals = player.teamGoals + game.blueScore | 0;
      newrecord.games = player.games + 1 | 0;
      newrecord.absoluteLosses = redWin && isAbsolute ? player.absoluteLosses + 1 | 0 : player.absoluteLosses;
      newrecord.absoluteWins = blueWin && isAbsolute ? player.absoluteWins + 1 | 0 : player.absoluteWins;
      newrecord.losses = redWin ? player.losses + 1 | 0 : player.losses;
      newrecord.wins = blueWin ? player.wins + 1 | 0 : player.wins;
      players[player.key] = newrecord;
    });
    match$2[1].forEach(player => {
      let lastGames = Players.getLastGames(player.lastGames, redWin);
      let newrecord = {...player};
      newrecord.lastGames = lastGames;
      newrecord.redWins = redWin ? player.redWins + 1 | 0 : player.redWins;
      newrecord.redGames = player.redGames + 1 | 0;
      newrecord.teamGoalsAgainst = player.teamGoalsAgainst + game.blueScore | 0;
      newrecord.teamGoals = player.teamGoals + game.redScore | 0;
      newrecord.games = player.games + 1 | 0;
      newrecord.absoluteLosses = blueWin && isAbsolute ? player.absoluteLosses + 1 | 0 : player.absoluteLosses;
      newrecord.absoluteWins = redWin && isAbsolute ? player.absoluteWins + 1 | 0 : player.absoluteWins;
      newrecord.losses = blueWin ? player.losses + 1 | 0 : player.losses;
      newrecord.wins = redWin ? player.wins + 1 | 0 : player.wins;
      players[player.key] = newrecord;
    });
    return {
      totalGames: stats.totalGames + 1 | 0,
      totalRedWins: stats.totalRedWins + (
        redWin ? 1 : 0
      ) | 0,
      totalBlueWins: stats.totalBlueWins + (
        blueWin ? 1 : 0
      ) | 0,
      totalAbsoluteWins: stats.totalAbsoluteWins + (
        isAbsolute ? 1 : 0
      ) | 0,
      totalDartsGames: stats.totalDartsGames
    };
  });
  let stats$1 = Core__Array.reduce(dartsGames, stats, (stats, game) => {
    let winners = game.winners.map(key => Core__Option.getExn(players[key], undefined));
    let losers = game.losers.map(key => Core__Option.getExn(players[key], undefined));
    let match = Elo.calculateScore(winners, losers, "Darts");
    match[0].forEach(player => {
      let lastGames = Players.getLastGames(player.dartsLastGames, true);
      let newrecord = {...player};
      newrecord.dartsLastGames = lastGames;
      newrecord.dartsWins = player.dartsWins + 1 | 0;
      newrecord.dartsGames = player.dartsGames + 1 | 0;
      newrecord.dartsLastEloChange = player.dartsLastEloChange;
      newrecord.dartsElo = player.dartsElo;
      players[player.key] = newrecord;
    });
    match[1].forEach(player => {
      let lastGames = Players.getLastGames(player.dartsLastGames, false);
      let newrecord = {...player};
      newrecord.dartsLastGames = lastGames;
      newrecord.dartsLosses = player.dartsLosses + 1 | 0;
      newrecord.dartsGames = player.dartsGames + 1 | 0;
      newrecord.dartsLastEloChange = player.dartsLastEloChange;
      newrecord.dartsElo = player.dartsElo;
      players[player.key] = newrecord;
    });
    return {
      totalGames: stats.totalGames,
      totalRedWins: stats.totalRedWins,
      totalBlueWins: stats.totalBlueWins,
      totalAbsoluteWins: stats.totalAbsoluteWins,
      totalDartsGames: stats.totalDartsGames + 1 | 0
    };
  });
  console.log(stats$1);
  console.log(players);
  await Promise.all(playerKeys.map(key => Players.writePlayer(Core__Option.getExn(players[key], undefined))));
  await writeStats(stats$1);
  return stats$1;
}

export {
  _ignoreOpenSkill,
  statsSchema,
  empty,
  bucket,
  fetchStats,
  useStats,
  updateStats,
  updateDartsStats,
  writeStats,
  recalculateStats,
}
/* _ignoreOpenSkill Not a pure module */
